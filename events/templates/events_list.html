<!DOCTYPE html>
<html>
  <head>
    <title>Event Log</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-streaming"></script>
    <style>
      table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 20px;
      }
      th,
      td {
        padding: 12px;
        text-align: left;
        border-bottom: 1px solid #ddd;
      }
      th {
        background-color: #f5f5f5;
      }
      .error {
        color: #dc3545;
      }
      .success {
        color: #28a745;
      }
      .button {
        padding: 10px 20px;
        margin: 10px;
        cursor: pointer;
      }
      .generating {
        background-color: #dc3545;
      }
      .not-generating {
        background-color: #28a745;
      }
    </style>
  </head>
  <body>
    <h1>Event Log</h1>

    <button
      id="generateBtn"
      class="button {% if is_generating %}generating{% else %}not-generating{% endif %}"
      onclick="toggleGeneration()"
    >
      {% if is_generating %}Stop Generation{% else %}Start Generation{% endif %}
    </button>

    <div style="width: 800px; height: 400px">
      <canvas id="latencyChart"></canvas>
    </div>

    <!-- Add time range controls -->
    <select id="timeRange">
      <option value="5">Last 5 minutes</option>
      <option value="15">Last 15 minutes</option>
      <option value="60">Last hour</option>
      <option value="360">Last 6 hours</option>
    </select>

    <select id="interval">
      <option value="10">10 seconds</option>
      <option value="30">30 seconds</option>
      <option value="60">1 minute</option>
      <option value="300">5 minutes</option>
    </select>

    <!-- Event Table -->
    <table>
      <thead>
        <tr>
          <th>Timestamp</th>
          <th>Method</th>
          <th>Source</th>
          <th>Status</th>
          <th>Duration</th>
          <th>Details</th>
        </tr>
      </thead>
      <tbody>
        {% for event in events %}
        <tr>
          <td>{{ event.timestamp|date:"Y-m-d H:i:s" }}</td>
          <td>{{ event.method }}</td>
          <td>{{ event.source }}</td>
          <td
            class="{% if event.status_code >= 400 %}error{% else %}success{% endif %}"
          >
            {{ event.status_code }}
          </td>
          <td>{{ event.duration_ms }}ms</td>
          <td>
            {% if event.status_code >= 400 %} {{ event.metadata.error_message }}
            {% else %} {{ event.message }} {% endif %}
          </td>
        </tr>
        {% endfor %}
      </tbody>
    </table>

    <!-- Generation controls -->
    <script>
      // Generation state and controls
      let isGenerating = {{ is_generating|lower }};

      async function toggleGeneration() {
        const btn = document.getElementById('generateBtn');
        const endpoint = isGenerating ? '/stop/' : '/start/';
        
        try {
          await fetch(endpoint);
          isGenerating = !isGenerating;
          
          btn.textContent = isGenerating ? 'Stop Generation' : 'Start Generation';
          btn.classList.toggle('generating');
          btn.classList.toggle('not-generating');
          
          if (!isGenerating) {
            latencyChart.update();
          }
        } catch (error) {
          console.error('Error toggling generation:', error);
        }
      }
    </script>

    <!-- Chart configuration and data handling -->
    <script>
      // Constants
      const REFRESH_RATES = {
        '10': 2000,
        '30': 5000,
        '60': 10000
      };

      // Chart setup and configuration
      const ctx = document.getElementById('latencyChart').getContext('2d');
      const latencyChart = new Chart(ctx, {
        type: 'line',
        data: {
          datasets: [{
            label: 'Average Latency (ms)',
            data: [],
            borderColor: 'rgb(75, 192, 192)',
            backgroundColor: 'rgba(75, 192, 192, 0.2)',
            fill: true
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              type: 'realtime',
              realtime: {
                duration: 300000,
                delay: 0,
                refresh: 1000,
                onRefresh: () => {}
              }
            },
            y: {
              beginAtZero: true
            }
          }
        }
      });

      // Add SSE listener (place this after chart initialization)
      const eventSource = new EventSource('/api/events-stream/');
      eventSource.onmessage = function(event) {
        if (!isGenerating) return;
        
        const data = JSON.parse(event.data);
        if (!data.timestamp) return;  // Skip empty updates
        
        latencyChart.data.datasets[0].data.push({
          x: data.timestamp,
          y: data.latency
        });
        latencyChart.update('none');
      };
    </script>

    <!-- Data fetching and updates -->
    <script>
      async function handleChartRefresh(chart) {
        if (!isGenerating) return;

        const interval = document.getElementById('interval').value;
        const timeRange = document.getElementById('timeRange').value;
        
        try {
          const response = await fetch(`/api/latency-data/?interval=${interval}&range=${timeRange}`);
          const data = await response.json();
          
          chart.data.datasets[0].data.push({
            x: Date.now(),
            y: data.latest_latency
          });
        } catch (error) {
          console.error('Error fetching latest data:', error);
        }
      }

      async function loadHistoricalData() {
        const interval = document.getElementById('interval').value;
        const timeRange = document.getElementById('timeRange').value;
        
        try {
          const response = await fetch(`/api/historical-latency-data/?interval=${interval}&range=${timeRange}`);
          const data = await response.json();
          
          latencyChart.data.datasets[0].data = data.data;
          latencyChart.update('none');
        } catch (error) {
          console.error('Error loading historical data:', error);
        }
      }
    </script>

    <!-- Event listeners -->
    <script>
      document.getElementById('timeRange').addEventListener('change', (e) => {
        const rangeMinutes = parseInt(e.target.value);
        latencyChart.options.scales.x.realtime.duration = rangeMinutes * 60 * 1000;
        loadHistoricalData();
      });

      document.getElementById('interval').addEventListener('change', (e) => {
        const refreshRate = REFRESH_RATES[e.target.value];
        latencyChart.options.scales.x.realtime.refresh = refreshRate;
        loadHistoricalData();
      });

      // Initialize
      loadHistoricalData();
    </script>
  </body>
</html>
